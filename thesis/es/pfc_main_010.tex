%
% PLANIFICACIÓN Y METODOLOGÍA
%
\chapter{
	Planificación y metodología
	\label{nombre_referencia_al_capitulo}
}

Este capítulo explica la metodología escogida para el desarrollo de este proyecto. Al tener este una importante componente investigadora, que complicaba una planificación y seguimiento tradicionales, basados en metodologías clásicas, se pensó que encajaría perfectamente un sistema ágil como el que a continuación se describe para el desarrollo del proyecto. Se incluye también un diagrama de \textit{Gantt} con los plazos e hitos que se siguieron en este trabajo.


\section{Desarrollo ágil de software}

El desarrollo ágil de software refiere a métodos de ingeniería del software basados en el desarrollo iterativo e incremental, donde los requisitos y soluciones evolucionan mediante la colaboración de grupos auto organizados y multidisciplinarios. Existen muchos métodos de desarrollo ágil; la mayoría minimiza riesgos desarrollando software en lapsos cortos. El software desarrollado en una unidad de tiempo es llamado una iteración, la cual debe durar de una a cuatro semanas. Cada iteración del ciclo de vida incluye: planificación, análisis de requisitos, diseño, codificación, revisión y documentación. Una iteración no debe agregar demasiada funcionalidad para justificar el lanzamiento del producto al mercado, sino que la meta es tener una «demo» (sin errores) al final de cada iteración. Al final de cada iteración el equipo vuelve a evaluar las prioridades del proyecto.

Los métodos ágiles enfatizan las comunicaciones cara a cara en vez de la documentación. La mayoría de los equipos ágiles están localizados en una simple oficina abierta, a veces llamadas «plataformas de lanzamiento» (\emph{bullpen} en inglés). La oficina debe incluir revisores, escritores de documentación y ayuda, diseñadores de iteración y directores de proyecto. Los métodos ágiles también enfatizan que el software funcional es la primera medida del progreso. Combinado con la preferencia por las comunicaciones cara a cara, generalmente los métodos ágiles son criticados y tratados como «indisciplinados» por la falta de documentación técnica.

Los métodos de desarrollo ágiles e iterativos pueden ser vistos como un retroceso a las prácticas observadas en los primeros años del desarrollo de software (aunque en ese tiempo no había metodologías formales). Inicialmente, los métodos ágiles fueron llamados métodos de «peso liviano».

\subsection[Agile Manifesto]{Agile Manifesto}
En el año 2001, miembros prominentes de la comunidad se reunieron en Snowbird, Utah, para discutir métodos de desarrollo ligero, publicando lo que denominaron \textit{Manifesto for Agile Software Development} y sentando las bases de lo que ahora se conoce como Desarrollo ágil de software. Las principales ideas sobre las que se sostiene son:
\begin{itemize}
	\item \textbf{Individuos e interacciones} auto-organización y la motivación son importantes. Otros valores promovidos son la co-ubicación y la programación en parejas.
	\item \textbf{Software funcionando} priorizando el tener \textit{demos} funcionales frente a documentación. 
	\item \textbf{Colaboración con el cliente} los requerimientos técnicos muchas veces no pueden ser definidos al principio del ciclo de desarrollo, por lo que la continua participación con el cliente es muy importante
	\item \textbf{Respuesta ante el cambio} centrándose en respuestas rápidas a los cambios y el desarrollo continuo.
\end{itemize}

\subsection[Principios Ágiles]{Principios Ágiles}

Este manifesto está basado en los siguientes 12 principios:

\begin{itemize}
	\item Nuestra mayor prioridad es satisfacer al cliente
	mediante la entrega temprana y continua de software
	con valor.
	
	\item Aceptamos que los requisitos cambien, incluso en etapas 
	tardías del desarrollo. Los procesos Ágiles aprovechan
	el cambio para proporcionar ventaja competitiva al 
	cliente.
	
	\item Entregamos software funcional frecuentemente, entre dos
	semanas y dos meses, con preferencia al periodo de 
	tiempo más corto posible.
	
	\item Los responsables de negocio y los desarrolladores
	trabajamos juntos de forma cotidiana durante todo
	el proyecto.
	
	\item Los proyectos se desarrollan en torno a individuos 
	motivados. Hay que darles el entorno y el apoyo que 
	necesitan, y confiarles la ejecución del trabajo. 
	
	\item El método más eficiente y efectivo de comunicar 
	información al equipo de desarrollo y entre sus 
	miembros es la conversación cara a cara.
	
	\item El software funcionando es la medida principal de 
	progreso.
	
	\item Los procesos Ágiles promueven el desarrollo 
	sostenible. Los promotores, desarrolladores y usuarios
	debemos ser capaces de mantener un ritmo constante 
	de forma indefinida.
	
	\item La atención continua a la excelencia técnica y al 
	buen diseño mejora la Agilidad.
	
	\item La simplicidad, o el arte de maximizar la cantidad de
	trabajo no realizado, es esencial.
	
	\item Las mejores arquitecturas, requisitos y diseños
	emergen de equipos auto-organizados.
	
	\item A intervalos regulares el equipo reflexiona sobre
	cómo ser más efectivo para a continuación ajustar y
	perfeccionar su comportamiento en consecuencia.
\end{itemize}

\subsection[Aplicación]{Aplicación}

En gran parte del proyecto fueron aplicadas premisas e ideas propuestas en este \textit{Agile Manifesto}. Se hicieron reuniones semanales en las que se discutían las siguientes tareas a llevar a cabo, dividiendo objetivos principales en tareas simples que no supusiesen más de 2 semanas de desarrollo. El trabajo en cada iteración era constante, centrándose siempre en completar la tarea y no asumiendo cambios si no eran profundamente necesarios.

El diseño incremental también estuvo fuertemente presente, puesto que en cada momento el diseño era revisado para adaptarlo a los nuevos requesitos.

Las revisiones con las dos personas a cargo de la dirección de proyecto fueron, siempre que fue posible, cara a cara. En cada reunión se comentaba qué objetivos habían sido cumplidos desde la última vez, y qué objetivos se intentarían abordar en la siguiente iteración. Cuando estas reuniones no eran posibles, sistemas como el correo electrónico o plataformas de \textit{chat} como \textit{Hangouts} o \textit{Telegram} fueron utilizados.

Para una adecuada gestión de las nuevas versiones producidas con la
incorporación de las nuevas características introducidas en la
aplicación durante cada iteración se empleó un sistema de control de
versiones moderno, libre y distribuido: \texttt{Git}. Este sistema
de administración de código fuente y distribución permite un trabajo
eficiente con múltiples ramas de desarrollo, lo que resultó muy útil
para el proyecto, facilitando la creación de nuevas ramas paralelas a
la versión estable, con pruebas para nuevos algoritmos. Además, para
mantener el código accesible en todo momento, desde el comienzo del
desarrollo se utilizó un servicio de \texttt{Git} en la «nube»,
\textit{github}\footnote{\url{https://github.com/eipporko/Cube}}, lo que no
solo favoreció una interacción fluida entre estudiante y directores,
sino que sirvió además como un sistema de \textit{backup} que permitía
también llevar el seguimiento del desarrollo. Destacar también el
aprovechamiento de la herramienta de integración continua
\texttt{travis}\footnote{\url{https://travis-ci.org/eipporko/Cube}}, también
en la «nube», que ayudó a mantener versiones compilables en las distintas
plataformas del repositorio en \textit{github}.

A pesar de que el evidente componente de investigación que tiene este
proyecto, en el que se van a emplear técnicas que son ahora mismo
estado del arte en computación gráfica, imposibilita en gran medida
una adecuada estimación de tiempo por cada iteración, el diagrama de
\textit{Gantt} de las {\figurename}s~\ref{figure_gantt_part1} y
\ref{figure_gantt_part2} viene a resumir los tiempos que llevó cada
iteración. La tabla del \tablename~\ref{tab:tareas} muestra las
principales tareas llevadas a cabo en esas interaciones.

\begin{table}
\centering
\begin{tabular}{l c c}
	\toprule
	\textbf{Tarea} & \textbf{Fecha de inicio} & \textbf{Fecha de fin}\\\midrule
	\textbf{Creación de prototipo} & \textbf{1/05/15} & \textbf{5/05/15} \\ 
	\indent Configuración del entorno de trabajo + CMake & 1/05/15 & 1/05/15 \\ 
	\indent Inicialización de contexto & 4/05/15 & 4/05/15 \\ 
	\indent Test de OpenGL + Shader básico & 5/05/15 & 5/05/15 \\[0.15cm]
	\textbf{Inclusión de una cámara orbital} & \textbf{6/05/15}  & \textbf{7/05/15} \\ 
	\indent Instalación de GLM & 6/05/15 & 6/05/15 \\ 
	\indent Implementación de la cámara & 7/05/15 & 7/05/15 \\ [0.15cm]
	\textbf{Sized-Fixed Point} & \textbf{8/05/15} & \textbf{11/05/15} \\
	\indent Generación de buffers en la GPU & 8/05/15  & 8/05/15 \\ 
	\indent Clase VAO + Shader Sized-Fixed Point & 11/05/15 & 11/05/15 \\ [0.15cm]
	\textbf{Port de GLUT a GLFW} & \textbf{12/05/15} & \textbf{12/05/15} \\ [0.15cm]
	\textbf{Image-aligned Squares Shader} & \textbf{13/05/15} & \textbf{19/05/15} \\ [0.15cm]
	\textbf{Sistema de cambio de Shader} & \textbf{20/05/15} & \textbf{20/05/15} \\ [0.15cm]
	\textbf{Affinely Projected Point Sprites Shader} & \textbf{21/05/15}  & \textbf{25/05/15} \\ [0.15cm]
	\textbf{Soporte con PCL} & \textbf{26/05/15} & \textbf{27/05/15} \\
	\indent Carga de formatos .PLY y .PCD & 26/05/15 & 26/05/15 \\ 
	\indent Refactorización hacia estructura cloud de PCL  & 26/05/15 &  27/05/15\\ [0.15cm]
	\textbf{Perspectively Correct Rasterization Shader} & \textbf{28/05/15} & \textbf{10/06/15} \\ [0.15cm]
	\textbf{Radio del splat variable según vecindad} & \textbf{11/06/15} & \textbf{12/06/15} \\ [0.15cm]
	\textbf{Gouraud Shading} & \textbf{15/06/15} & \textbf{2/07/15}  \\ 
	\indent Añadir al pipeline opción a sistema MultiPass & 15/06/15 & 18/06/15 \\ 
	\indent Gouraud Shading Shader & 19/06/15 & 2/07/15 \\ [0.1cm]
	\textbf{Implementación de FXAA} & \textbf{15/06/15} & \textbf{2/07/15}  \\ [0.15cm]
	\textbf{Gouraud Shading} & \textbf{3/07/15} & \textbf{6/07/15}  \\ [0.15cm]
	\textbf{Phong Shading Shader} & \textbf{7/07/15} & \textbf{13/07/15}  \\ [0.15cm]
	\textbf{Deferred Shading Shader} & \textbf{14/07/15} & \textbf{22/07/15}  \\[0.15cm]
	\textbf{Luz orbital} & \textbf{23/07/15} & \textbf{23/07/15} \\
	\bottomrule
\end{tabular}
\caption{Principales tareas llevadas a cabo en el proyecto.}
\label{tab:tareas}
\end{table}

En el siguiente diagrama de \textit{Gantt} (ver Figuras \ref{figure_gantt_part1} y \ref{figure_gantt_part2}) se pueden ver las tareas que fueron definidas en cada una de las iteraciones, siendo las más importantes las que hacen referencia a la implementación del algoritmo \textit{Perspective Correct} y \textit{Gouraud Shading} en el que hubo que hacer modificaciones en el visualizador bastante críticas para poderlo adaptarlo a los requisitos de estos algoritmos.

\begin{figure}
	\centering
	\includegraphics[width=14cm]{../figures/gantt_part1.eps}
        \caption{Diagrama de Gant (I).}
	\label{figure_gantt_part1}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=6.72cm]{../figures/gantt_part2.eps}
        \caption{Diagrama de Gant (II).}
	\label{figure_gantt_part2}
\end{figure}

Se tiene además un presupuesto (ver Tabla \ref{presupuesto}) para un proyecto como este. Incluyendo únicamente costes humanos y \textit{hardware}, ya que el \textit{software} fue siempre gratuito. El precio por hora del ordenador fue calculado pensando en una amortización de 5 años fiscales para el equipo. \\

\begin{table}
\centering
\begin{tabular}{l c c c c}
	\toprule
	\textbf{Recurso} & \textbf{Cantidad} & \textbf{Horas} & \textbf{Coste por hora} & \textbf{Total} \\\midrule
	Software & & & & 0\officialeuro \\
	Ordenador & 1 & 480 & 0,1372\officialeuro & 65,86\officialeuro \\
	Analista-Programador & 1 & 480 & 15\officialeuro & 7200\officialeuro \\\cmidrule(lr){5-5}
	& & & & 7265,86\officialeuro \\
	\bottomrule
\end{tabular}
\caption{Estimación de coste.}
\label{presupuesto}
\end{table}


%
% FIN DEL CAPÍTULO
%
